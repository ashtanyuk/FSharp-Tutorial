{
  "name": "Fsharp-tutorial",
  "tagline": "Краткое введение в F#",
  "body": "# Краткое введение в FSharp\r\n\r\n![](./pics/fsharp256.png)\r\n\r\n## Введение\r\n\r\n**F#** (эф-шарп) разработан в *Microsoft Corporation* в 2005 году. Информация о языке и необходимое програмное обеспечение доступно по адресу [http://fsharp.org](). Имеется поддержка языка в популярном пакете разработчика *Visual Studio*, он также доступен для *Linux* и *Mac OS X*.\r\n\r\n## Особенности программирования на FSharp\r\n\r\n - основное назначение языка: программирование в функциональном стиле, но есть поддержка императивного и объектно-ориентированного стилей;\r\n - отступы и пробелы имеют значение при форматировании кода;\r\n - доступен режим интерпретатора, в котором можно выполнить команды (REPL), но можно использовать традиционный компилятор для получения исполняемого файла;\r\n - язык F# многое взял от **OCaml**;\r\n - доступны типы и библиотека .NET;\r\n - язык имеет строгую типизацию.\r\n\r\n\r\n**Замечание**\r\n*Все дальнейшие примеры приведены для интерактивной оболочки. Символ '>' всегда обозначает приглашение интерпретатора и не набирается пользователем*\r\n\r\n## REPL\r\n\r\nПри использовании **MS Visual Studio** можно открыть окно **F# interactive** и вводить команды. Можно выделить в программе текст и послать его в REPL комбинацией: *Alt+Enter*.\r\n\r\nВне *Visual Studio* запустить интерпретатор можно программой *fsi*.\r\n\r\n## Примеры использования .NET\r\n\r\n```F#\r\n> open System;;\r\n> let now = DateTime.Now;;\r\n\r\nval now : DateTime = 06.11.2016 15:29:42\r\n\r\n>Math.PI;;\r\nval it : float = 3.141592654\r\n```\r\n\r\n## Комментарии\r\n\r\n```F#\r\n// - однострочный комментарий\r\n(*\r\n Многострочный комментарий\r\n (может занимать несколько строк)\r\n*)\r\n```\r\n\r\n## Данные\r\n\r\n### Стандартные типы\r\n\r\nНиже перечислены основные типы с указанием суффиксов при связывании значений с именами:\r\n\r\n- **byte** - _uy_ - беззнаковый байт\r\n- **sbyte** - _y_ - знаковый байт\r\n- **int16** - _s_ - короткое целое\r\n- **uint16** - _us_ - беззнаковое короткое целое\r\n- **int32** - по-умолчанию - обычное целое\r\n- **uint32** - _u_ - беззнаковое целое\r\n- **int64** - _L_ - длинное целое\r\n- **uint64** - _UL_ -  беззнаковое длинное целое\r\n- **float32** - _f_ - вещественное одинарной точности\r\n- **float** - вещественное двойной точности\r\n- **decimal** - _M_ - вещественное фиксированной точности (28 цифр после запятой)\r\n\r\n### Присвоение значений\r\n\r\nПоскольку **F#** - функциональный язык, то переменные в классическом (императивном) смысле в нем не приветствуются. Просто вводится имя и этому имени присваивается значение, которое в дальнейшем не может быть изменено.\r\n\r\nПримеры создания значений:\r\n\r\n```F#\r\nlet a = 7uy\r\nlet b = -18s\r\nlet c = 0b1010101y\r\n```\r\n\r\nПримеры с возведением в степень:\r\n\r\n```F#\r\n> let d = 2UL 56;;\r\nval b : uint64 = 72057594037927936UL\r\n```\r\n\r\n### Преобразования типов\r\n\r\nЯвные преобразования типов необходимы, поскольку в языке практически отсутствуют неявные преобразования. \r\n\r\nФункции преобразования имеют такие же названия, что и типы, например:\r\n\r\n```F#\r\n>let e = uint64 2;;\r\nval e : uint64 = 2UL\r\n```\r\n\r\n### Сверхдлинные числа\r\n\r\n```F#\r\n>open System.Numerics;;\r\n>let f = 2I ** 200 ;;\r\nval f : BigInteger = \r\n  16069380442589902755419620923411626.......\r\n```\r\n\r\n### Символы и строки\r\n\r\nВсе символы хранятся в юникоде:\r\n\r\n```F#\r\n>let ch = 'л';;\r\nval ch : char = 'л'\r\n> int ch;;\r\nvat it : int = 1083\r\n```\r\n\r\nСтроки:\r\n\r\n```F#\r\n>let hello = \"hello, world!\";;\r\nval hello : string = \"hello, world!\"\r\n> hello.[1]\r\nval it : char = 'e'\r\n```\r\n\r\n## Структуры данных\r\n\r\nВ качестве *структур данных* выступают:\r\n\r\n- списки (*lists*);\r\n- кортежи (*tupples*);\r\n- массивы (*arrays*);\r\n- последовательности (*sequences*);;\r\n\r\n### Списки\r\n\r\nСписки являются основной структурой данных в функцинальных языках. \r\n\r\nЗадать список легко:\r\n\r\n```F#\r\n>let list = [1;2;3];;\r\nval list : int list = [1; 2; 3]\r\n```\r\n\r\nМожно указывать диапазоны значений:\r\n\r\n```F#\r\n> let list = [1..10];;\r\nval list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n\r\n> let list = ['a'..'z'];;\r\nval list : char list =\r\n  ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l'; 'm'; 'n'; 'o';\r\n   'p'; 'q'; 'r'; 's'; 't'; 'u'; 'v'; 'w'; 'x'; 'y'; 'z']\r\n```\r\n\r\nПример определения списка с шагом:\r\n\r\n```F#\r\n> let lst = [1 .. 2 .. 10];;\r\nval lst : int list = [1; 3; 5; 7; 9]\r\n```\r\n\r\nМы можем использовать для создания списка **генераторы**, - специальные конструкции, заключенные в квадратные скобки:\r\n\r\n```F#\r\n> let evens = [\r\n  for i in 1..10 do\r\n    if i % 2 = 0 then\r\n      yield i\r\n]\r\nval evens : int list = [2; 4; 6; 8; 10]\r\n```\r\n\r\nВариант с использованием *лямбда-функции*:\r\n\r\n```F#\r\nlet lst = [for i in 1..10 -> i*i] // [1, 4, 9,..]\r\n```\r\n\r\n\r\n\r\n### Кортежи\r\n..\r\n\r\n### Массивы\r\n..\r\n\r\n### Последовательности\r\n..\r\n\r\n\r\n## Операторы и операции\r\n\r\nВ языке F# имеется набор операторов, поддерживающих управляющую логику и циклы.\r\n\r\n```F#\r\n..\r\nlet choice a b =\r\n   if a>b then 'a' else 'b'\r\n```\r\n\r\nОбработка списка циклом **for**:\r\n\r\n```F#\r\n> let lst = [1..10];;\r\nval lst : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n\r\n> for item in lst do printfn \"%A\" item;;\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\nval it : unit = ()\r\n```\r\n\r\nОператор **yield** используется для возвращения элемента из функции или цикла, например, для формирования списка (см. пример в разделе \"списки\"). \r\n\r\n\r\n\r\n\r\n\r\n## Функции\r\n\r\nДля функционального языка программирования **функция** - центральное понятие.\r\n\r\n```F#\r\n>let square = x * x;;\r\nval square : int -> int\r\n\r\n>square 2;;\r\nval it : int = 4\r\n```\r\n\r\nФункция **square** принимает параметр *int* и возвращает результат типа *int*.\r\n\r\n\r\nДругая функция использует в работе ранее определенную:\r\n\r\n```F#\r\n> let sum_of_squares x y = square x + square y;;\r\nval sum_of_squares : x:int -> y:int -> int\r\n\r\n> sum_of_squares 3 4;;\r\nval it : int = 25\r\n```\r\n\r\nСтранный тип выражения становится понятным, если рассмотреть следующий пример:\r\n\r\n```F#\r\n> let add x y = x + y;;\r\nval add : int -> int -> int\r\n```\r\n\r\nВ данном случае функция *add* принимает два параметра и возвращает функцию, принимающую один параметр, возвращая, в свою очередь, целое число. Этот пример позволяет понять свойство *карриуемости*:\r\n\r\nФункции могут быть *каррированными*, то есть в них не передается весь набор параметров сразу:\r\n\r\n```F#\r\n> let add x y = x + y;;\r\nval add : x:int -> y:int -> int\r\n\r\n> let inc = add 1;;\r\nval inc : (int -> int)\r\n\r\n> inc 5;;\r\nval it : int = 6\r\n```\r\n\r\nМожно явно указать типы параметров:\r\n\r\n```F#\r\n>let add (x : float) y = x + y;;\r\nval add : float -> float -> float\r\n```\r\n\r\nПараметр обобщенного типа:\r\n\r\n```F#\r\n>let prn (x : 'a) = x;;\r\nval prn : 'a -> 'a\r\n```\r\n\r\nВ качестве обобщенного типа может использоваться любой тип. \r\n\r\nБезымянные функции (*лямбда-функции*) задаются без имени:\r\n\r\n```F#\r\n> fun x -> x * x;;\r\nval it : x:int -> int = <fun:clo@9>\r\n> it 6;;\r\nval it : int = 36\r\n```\r\n\r\nЛямбда-функции являются очень удобным инструментом при обработках элементов структур данных.\r\n\r\n#### О важности пробелов (отступов)\r\n\r\nВ теле функции мы используем отступы, чтобы отделить внутренние определения от их использования:\r\n\r\n```F#\r\n> let mid x y =\r\n-   let sum a b =\r\n-     a + b\r\n-   (sum x y) / 2;;\r\nval mid : x:int -> y:int -> int\r\n\r\n> mid 4 2;;\r\nval it : int = 3\r\n```\r\n\r\n#### Рекурсия\r\n\r\n**Рекурсивные** функции используются для реализации циклических алгоритмов:\r\n\r\n```F#\r\n> let rec factor n = \r\n      if n<=1 then \r\n         1 \r\n      else \r\n         n * factor (n - 1);;\r\n\r\nval factor : n:int -> int\r\n\r\n> factor 10;;\r\nval it : int = 3628800\r\n```\r\n\r\n### Генераторы списков\r\n\r\nОчень полезны **генераторы** (специальные функции для генерации значений):\r\n\r\n..\r\n\r\n## Литература\r\n\r\n- Крис Смит. *Программирование на F#*, Символ-Плюс, 2011.\r\n- Chris Smith. *Programming F#*, O'Reilly Media, 2009.\r\n- Jon Harrop, Don Syme. *F# for Scientists*, Wiley-Interscience, 2008.\r\n- Robert Pickering, Kit Eason. *Beginning F# 4.0*, Apress, 2016.\r\n- Dave Fancher. *The Book of F#: Breaking Free With Managed Functional Programming*, No Starch Press, 2014.\r\n- Adnan Masood. *Learning F# Functional Data Structures and Algorithms*, Packt, 2015.\r\n- Tomas Petricek, Phillip Trelford. *F# Deep Dives, Manning Publications*, 2014.\r\n- swlaschin. *F# for Fun and Profit*, GITBOOK\r\n- James Graff. *The Fsharp Handbook*, CreateSpace, 2016.\r\n- Tomas Petricek, Jon Skeet. *Real-World Functional Programming: With Examples in F# and C#*, Manning Publications, 2010.\r\n- Robert Pickering. *Foundations of F#*, Apress, 2007.\r\n- Robert Pickering. *Beginning F#*, Apress, 2009.\r\n- Don Syme. *Expert F#*, Apress, 2007.\r\n- Michael R. Hansen, Hans Rischel. *Functional Programming Using F#*, Cambridge Press, 2013.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}