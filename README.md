# Краткое введение в FSharp


## Введение

**F#** (эф-шарп) разработан в *Microsoft Corporation* в 2005 году. Информация о языке и необходимое програмное обеспечение доступно по адресу [http://fsharp.org](). Имеется поддержка языка в популярном пакете разработчика *Visual Studio*, он также доступен для *Linux* и *Mac OS X*.

## Особенности программирования на FSharp

 - основное назначение языка: программирование в функциональном стиле, но есть поддержка императивного и объектно-ориентированного стилей;
 - отступы и пробелы имеют значение при форматировании кода;
 - доступен режим интерпретатора, в котором можно выполнить команды (REPL), но можно использовать традиционный компилятор для получения исполняемого файла;
 - язык F# многое взял от **OCaml**;
 - доступны типы и библиотека .NET;
 - язык имеет строгую типизацию.


**Замечание**
*Все дальнейшие примеры приведены для интерактивной оболочки. Символ '>' всегда обозначает приглашение интерпретатора и не набирается пользователем*

## REPL

При использовании **MS Visual Studio** можно открыть окно **F# interactive** и вводить команды. Можно выделить в программе текст и послать его в REPL комбинацией: *Alt+Enter*.

Вне *Visual Studio* запустить интерпретатор можно программой *fsi*.

## Пример использования .NET

```F#
> open System;;
> let now = DateTime.Now;;

val now : DateTime = 06.11.2016 15:29:42
```

## Комментарии

```F#
// - однострочный комментарий
(*
 Многострочный комментарий
 (может занимать несколько строк)
*)
```

## Данные

### Стандартные типы

Ниже перечислены основные типы с указанием суффиксов при связывании значений с именами:

- **byte** - _uy_ - беззнаковый байт
- **sbyte** - _y_ - знаковый байт
- **int16** - _s_ - короткое целое
- **uint16** - _us_ - беззнаковое короткое целое
- **int32** - по-умолчанию - обычное целое
- **uint32** - _u_ - беззнаковое целое
- **int64** - _L_ - длинное целое
- **uint64** - _UL_ -  беззнаковое длинное целое
- **float32** - _f_ - вещественное одинарной точности
- **float** - вещественное двойной точности
- **decimal** - _M_ - вещественное фиксированной точности (28 цифр после запятой)

### Присвоение значений

Поскольку **F#** - функциональный язык, то переменные в классическом (императивном) смысле в нем не приветствуются. Просто вводится имя и этому имени присваивается значение, которое в дальнейшем не может быть изменено.

Примеры создания значений:

```F#
let a = 7uy
let b = -18s
let c = 0b1010101y
```

Примеры с возведением в степень:

```F#
> let d = 2UL 56;;
val b : uint64 = 72057594037927936UL
```

### Преобразования типов

Явные преобразования типов необходимы, поскольку в языке практически отсутствуют неявные преобразования. 

Функции преобразования имеют такие же названия, что и типы, например:

```F#
>let e = uint64 2;;
val e : uint64 = 2UL
```

### Сверхдлинные числа

```F#
>open System.Numerics;;
>let f = 2I ** 200 ;;
val f : BigInteger = 
  16069380442589902755419620923411626.......
```

### Символы и строки

Все символы хранятся в юникоде:

```F#
>let ch = 'л';;
val ch : char = 'л'
> int ch;;
vat it : int = 1083
```

Строки:

```F#
>let hello = "hello, world!";;
val hello : string = "hello, world!"
> hello.[1]
val it : char = 'e'
```

## Структуры данных

В качестве *структур данных* выступают:

- списки (lists);
- кортежи (tupples);
- последовательности (sequences);;

### Списки

Списки являются основной структурой данных в функцинальных языках. 

Задать список легко:

```F#
>let list = [1;2;3];;
val list : int list = [1; 2; 3]
```

Можно указывать диапазоны значений:

```F#
> let list = [1..10];;
val list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

> let list = ['a'..'z'];;
val list : char list =
  ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l'; 'm'; 'n'; 'o';
   'p'; 'q'; 'r'; 's'; 't'; 'u'; 'v'; 'w'; 'x'; 'y'; 'z']
```

..

## Функции

Для функционального языка программирования **функция** - центральное понятие.

```F#
>let square = x * x;;
val square : int -> int
>square 2;;
val it : int = 4
```

Функция **square** принимает параметр *int* и возвращает результат типа *int*.

```F#
> let add x y = x + y;;
val add : int -> int -> int
```

В данном случае функция *add* принимает два параметра и возвращает функцию, принимающую один параметр, возвращая, в свою очередь, целое число. 

Можно явно указать типы параметров:

```F#
>let add (x : float) y = x + y;;
val add : float -> float -> float
```

Параметр обобщенного типа:

```F#
>let prn (x : 'a) = x;;
val prn : 'a -> 'a
```

В качестве обобщенного типа может использоваться любой тип. 


### Генераторы списков

Очень полезны **генераторы** (специальные функции для генерации значений):

..

## Литература

- *Крис Смит* **Программирование на F#**, Символ-Плюс, 2011.
- *Chris Smith* **Programming F#**, O'Reilly Media, 2009.
- *Jon Harrop, Don Syme* **F# for Scientists**, Wiley-Interscience, 2008.
- *Robert Pickering, Kit Eason* **Beginning F# 4.0**, Apress, 2016.
- *Dave Fancher* **The Book of F#: Breaking Free With Managed Functional Programming**, No Starch Press, 2014.
- *Adnan Masood* **Learning F# Functional Data Structures and Algorithms**, Packt, 2015.
- *Tomas Petricek, Phillip Trelford* **F# Deep Dives, Manning Publications**, 2014.
- *swlaschin* **F# for Fun and Profit**, GITBOOK
- *James Graff* **The Fsharp Handbook**, CreateSpace, 2016.
- *Tomas Petricek, Jon Skeet* **Real-World Functional Programming: With Examples in F# and C#**, Manning Publications, 2010.
- *Robert Pickering* **Foundations of F#**, Apress, 2007.
- *Robert Pickering* **Beginning F#**, Apress, 2009.
- *Don Syme* **Expert F#**, Apress, 2007.
- *Michael R. Hansen, Hans Rischel* **Functional Programming Using F#**, Cambridge Press, 2013.

















 
